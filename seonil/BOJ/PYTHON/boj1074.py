"""
BOJ1074. Z

[문제]
한수는 크기가 2^N × 2^N인 2차원 배열을 Z모양으로 탐색하려고 한다.
예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.

N > 1인 경우, 배열을 크기가 2^(N-1) × 2^(N-1)로 4등분 한 후에 재귀적으로 순서대로 방문한다.
다음 예는 2^2 × 2^2 크기의 배열을 방문한 순서이다.

N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.
다음은 N=3일 때의 예이다.

[입력]
첫째 줄에 정수 N, r, c가 주어진다.

[출력]
r행 c열을 몇 번째로 방문했는지 출력한다.

[제한]
1 ≤ N ≤ 15
0 ≤ r, c < 2N
"""

import sys
input = lambda: sys.stdin.readline().rstrip()

# main

# N : 배열의 크기(log2-scale), r, c : 우리가 찾고 싶은 좌표 (r행, c열)
N, r, c = map(int, input().split())

# 결과값: (r, c)가 Z 탐색에서 몇 번째로 방문되는지 저장하는 변수를 0으로 초기화
answer = 0

# N이 0이 될 때까지(배열 크기가 1x1이 될 때까지) 다음 과정을 반복
while N > 0:

    # half: 현재 배열의 절반 길이
    half = 2 ** (N - 1)

    # block: 한 사분면(블록) 안에 들어 있는 칸의 개수
    block = half ** 2

    # (r, c)가 어느 사분면에 속하는지 판단하기
    # Z 탐색 순서: 0번(왼쪽 위) → 1번(오른쪽 위) → 2번(왼쪽 아래) → 3번(오른쪽 아래)
    
    # (r, c)가 왼쪽 위(0번) 블록이라면
    if r < half and c < half:
        # 이미 지나온 칸 없으므로 pass!
        pass

    # (r, c)가 오른쪽 위(1번) 블록이라면
    elif r < half and c >= half:
        # 0번 블록의 모든 칸을 이미 방문함
        answer += block
        # 좌표를 현재 사분면 기준으로 변환
        c -= half

    # (r, c)가 왼쪽 아래(2번) 블록이라면
    elif r >= half and c < half:
        # 0번, 1번 사분면의 모든 칸을 이미 방문함
        answer += 2 * block
        # 좌표를 현재 사분면 기준으로 변환
        r -= half
    
    # (r, c)가 오른쪽 아래(3번) 블록이라면
    else:
        # 0번, 1번, 2번 사분면의 모든 칸을 이미 방문함
        answer += 3 * block
        # 좌표를 현재 사분면 기준으로 변환
        r -= half
        c -= half

    # 배열의 크기를 절반으로 줄여서 다시 위치 판단하기
    N -= 1

# 방문 순서 판단 과정 이후 결과 반환
print(answer)