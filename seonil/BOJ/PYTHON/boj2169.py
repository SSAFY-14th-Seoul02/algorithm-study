"""
BOJ2169. 로봇 조종하기

[문제]
NASA에서는 화성 탐사를 위해 화성에 무선 조종 로봇을 보냈다. 실제 화성의 모습은 굉장히 복잡하지만, 로봇의 메모리가 얼마 안 되기 때문에 지형을 N×M 배열로 단순화 하여 생각하기로 한다.
지형의 고저차의 특성상, 로봇은 움직일 때 배열에서 왼쪽, 오른쪽, 아래쪽으로 이동할 수 있지만, 위쪽으로는 이동할 수 없다.
또한 한 번 탐사한 지역(배열에서 하나의 칸)은 탐사하지 않기로 한다.

각각의 지역은 탐사 가치가 있는데, 로봇을 배열의 왼쪽 위 (1, 1)에서 출발시켜 오른쪽 아래 (N, M)으로 보내려고 한다.
이때, 위의 조건을 만족하면서, 탐사한 지역들의 가치의 합이 최대가 되도록 하는 프로그램을 작성하시오.

[입력]
첫째 줄에 N, M(1≤N, M≤1,000)이 주어진다.
다음 N개의 줄에는 M개의 수로 배열이 주어진다.
배열의 각 수는 절댓값이 100을 넘지 않는 정수이다. 이 값은 그 지역의 가치를 나타낸다.

[출력]
첫째 줄에 최대 가치의 합을 출력한다.
"""

import sys
input = lambda: sys.stdin.readline().rstrip()

# main
N, M = map(int, input().split())                            # N, M: 배열의 가로, 세로 크기
arr = [list(map(int, input().split())) for _ in range(N)]   # 지역 가치 배열 입력 받기

# dp[i][j] = (i, j) 위치에 도착했을 때 얻을 수 있는 최대 가치
dp = [[0] * M for _ in range(N)]

# 1. 첫 번째 행은 오른쪽으로만 이동 가능
dp[0][0] = arr[0][0]
for j in range(1, M):
    dp[0][j] = dp[0][j - 1] + arr[0][j]

# 2. 두 번째 행부터 dp 배열 연산 시작
for i in range(1, N):

    # a. 왼쪽 → 오른쪽으로 이동하는 경우
    # left[j] = (i, j)에 왼쪽 → 오른쪽 방향으로 진행하면서 도착했을 때 최댓값
    left = [0] * M
    left[0] = dp[i-1][0] + arr[i][0]

    for j in range(1, M):
        left[j] = max(
            dp[i-1][j],     # 위에서 내려오는 경우
            left[j-1]       # 같은 행 왼쪽에서 오는 경우
            ) + arr[i][j]   # 현재 칸의 값
    
    # b. 오른쪽 → 왼쪽으로 이동하는 경우
    # right[j] = (i, j)에 오른쪽 → 왼쪽 방향으로 진행하면서 도착했을 때 최댓값
    right = [0] * M
    right[M-1] = dp[i-1][M-1] + arr[i][M-1]

    for j in range(M-2, -1, -1):
        right[j] = max(
            dp[i-1][j], # 위에서 내려오는 경우
            right[j+1]  # 같은 행 오른쪽에서 오는 경우
        ) + arr[i][j]   # 현재 칸의 값
    
    # 두 방향에서 온 값 중 더 최적(최대 가치)인 것을 선택
    for j in range(M):
        dp[i][j] = max(left[j], right[j])

# 도착점(N-1, M-1)의 최대 가치 출력
print(dp[N-1][M-1])