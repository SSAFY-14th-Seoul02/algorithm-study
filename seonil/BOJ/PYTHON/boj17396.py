"""
BOJ17396. 백도어

[문제]
유섭이는 무척이나 게으르다. 오늘도 할 일을 모두 미뤄둔 채 열심히 롤을 하던 유섭이는 오늘까지 문제를 내야 한다는 사실을 깨달았다.
그러나 게임은 시작되었고 지는 걸 무척이나 싫어하는 유섭이는 어쩔 수 없이 백도어를 해 게임을 최대한 빠르게 끝내기로 결심하였다.

최대한 빨리 게임을 끝내고 문제를 출제해야 하기 때문에 유섭이는 최대한 빨리 넥서스가 있는 곳으로 달려가려고 한다.
유섭이의 챔피언은 총 N개의 분기점에 위치할 수 있다.
0번째 분기점은 현재 유섭이의 챔피언이 있는 곳을, N-1 번째 분기점은 상대편 넥서스를 의미하며 나머지 1, 2, ..., N-2번째 분기점은 중간 거점들이다.
그러나 유섭이의 챔피언이 모든 분기점을 지나칠 수 있는 것은 아니다. 백도어의 핵심은 안 들키고 살금살금 가는 것이기 때문에 적 챔피언 혹은 적 와드(시야를 밝혀주는 토템), 미니언, 포탑 등 상대의 시야에 걸리는 곳은 지나칠 수 없다.
입력으로 각 분기점을 지나칠 수 있는지에 대한 여부와 각 분기점에서 다른 분기점으로 가는데 걸리는 시간이 주어졌을 때, 유섭이가 현재 위치에서 넥서스까지 갈 수 있는 최소 시간을 구하여라.

[입력]
첫 번째 줄에 분기점의 수와 분기점들을 잇는 길의 수를 의미하는 두 자연수 N과 M이 공백으로 구분되어 주어진다.(1 ≤ N ≤ 100,000, 1 ≤ M ≤ 300,000)
두 번째 줄에 각 분기점이 적의 시야에 보이는지를 의미하는 N개의 정수 a0, a1, ..., aN-1가 공백으로 구분되어 주어진다. ai가 0이면 i 번째 분기점이 상대의 시야에 보이지 않는다는 뜻이며, 1이면 보인다는 뜻이다. 추가적으로 a0 = 0, aN-1 = 1이다., N-1번째 분기점은 상대 넥서스이기 때문에 어쩔 수 없이 상대의 시야에 보이게 되며, 또 유일하게 상대 시야에 보이면서 갈 수 있는 곳이다.
다음 M개의 줄에 걸쳐 세 정수 a, b, t가 공백으로 구분되어 주어진다. (0 ≤ a, b < N, a ≠ b, 1 ≤ t ≤ 100,000) 이는 a번째 분기점과 b번째 분기점 사이를 지나는데 t만큼의 시간이 걸리는 것을 의미한다.
연결은 양방향이며, 한 분기점에서 다른 분기점으로 가는 간선은 최대 1개 존재한다.

[출력]
첫 번째 줄에 유섭이의 챔피언이 상대 넥서스까지 안 들키고 가는데 걸리는 최소 시간을 출력한다. 만약 상대 넥서스까지 갈 수 없으면 -1을 출력한다.
"""

from heapq import heappop, heappush

import sys
input = lambda: sys.stdin.readline().rstrip()

def min_time_for_backdoor(spotted, start, goal):

    # 우선순위 큐: (현재까지 걸린 시간, 현재 위치)
    pq = [(0, start)]

    # 각 분기점까지의 최소 시간
    min_costs = [INF] * N
    min_costs[0] = 0

    # Dijkstra 시작
    while pq:

        # 지금까지 비용이 가장 작은 경로를 꺼냄
        cur_cost, cur_node = heappop(pq)

        # 이미 더 적은 비용으로 방문한 적이 있다면 스킵
        if min_costs[cur_node] < cur_cost:
            continue

        # 현재 노드에서 인접한 노드들로 이동 시도
        for each in adj_lst[cur_node]:
            edge_cost, next_node = each
            # 만약 다음 노드가 넥서스(목적지)가 아닌 상대 시야에 보이는 곳이라면 스킵
            if spotted[next_node] == 1:
                continue
            # 다음 노드로 이동하려면 간선 이동 시간만큼 시간 비용 발생
            new_cost = cur_cost + edge_cost
            # 이미 다음 노드에 더 적은 비용으로 도달 가능하다면 갱신 X
            if min_costs[next_node] <= new_cost:
                continue
            # 최소비용 갱신
            min_costs[next_node] = new_cost
            # 우선순위 큐에 새로운 상태 추가
            heappush(pq, (new_cost, next_node))

    # 다익스트라 종료 후 목적지까지의 최소비용 출력. 갱신 안되었다면 도달하지 못한 것이므로 -1 출력
    return min_costs[goal] if min_costs[goal] != INF else -1

# main
INF = 10e11
N, M = map(int, input().split())    # N: 분기점 수, M: 길의 수 입력 받기
spotted = list(map(int, input().split()))   # 상대 시야에 보이는 분기점 정보
spotted[N - 1] = 0  # 목적지는 예외적으로 상대 시야에 보이지만 이동 가능

# 인접 리스트 그래프
adj_lst = [[] for _ in range(N)]

# 양방향 간선 정보 입력 받기
for _ in range(M):
    a, b, t = map(int, input().split())
    adj_lst[a].append((t, b))
    adj_lst[b].append((t, a))

# 시작점 0에서 넥서스 N-1까지 최소 시간 출력
print(min_time_for_backdoor(spotted, 0, N - 1))

"""
주의할 점: 습관적으로 INF = 21e8라고 설정했더니 틀렸다 ㅇ_ㅇ;
이 문제에서 최악의 경우 0번 노드에서 (N-1)번 노드까지 모든 노드를 일렬로 거쳐 간다면:
max_cost = 100000 * 100000 = 10^10(100억)
이므로, 내가 습관적으로 설정한 INF 값을 넘어버린다...
문제 풀기 전에 값의 크기를 체크하면서 잘 판단하거나, 아니면 속시원하게 float('inf')를 쓰는게 좋을듯하다.
"""