# BOJ 14719. 빗물 / D3
'''
문제
2차원 세계에 블록이 쌓여있다. 비가 오면 블록 사이에 빗물이 고인다.
비는 충분히 많이 온다. 고이는 빗물의 총량은 얼마일까?

입력
첫 번째 줄에는 2차원 세계의 세로 길이 H과 2차원 세계의 가로 길이 W가 주어진다. (1 ≤ H, W ≤ 500)
두 번째 줄에는 블록이 쌓인 높이를 의미하는 0이상 H이하의 정수가 2차원 세계의 맨 왼쪽 위치부터 차례대로 W개 주어진다.
따라서 블록 내부의 빈 공간이 생길 수 없다. 또 2차원 세계의 바닥은 항상 막혀있다고 가정하여도 좋다.

출력
2차원 세계에서는 한 칸의 용량은 1이다. 고이는 빗물의 총량을 출력하여라.
빗물이 전혀 고이지 않을 경우 0을 출력하여라.
'''
import sys
input = sys.stdin.readline

H, W = map(int, input().split())
arr = [[0]*W for _ in range(H)]  # 이차원 세계를 표현할 이차원 배열

height = list(map(int, input().split()))
# height에 각 행에 쌓을 블록 개수를 받음
# 아래서 부터 블록을 쌓아도 되지만, 그냥 거꾸로 뒤집힌 상태로 표현
for i in range(W):
    for j in range(height[i]):
        arr[j][i] = 1

# 리스트에서 0의 인덱스를 찾아서 반환하는 함수
def find_z(lst):
    z_idx = []
    for i in range(len(lst)):
        if lst[i] == 0:
            z_idx.append(i)
    return z_idx

rain = 0 # 빗물의 초기값
for r in arr: # 한 행씩 확인
    check = find_z(r) # 함수를 활용하여 리스트에서 0의 인덱스를 저장
    while check: # check가 빌때까지 반복
        a = check.pop() # 0 인덱스 하나 뽑아서
        a_l, a_r = 0, 0 # 인덱스 a의 좌 우를 확인할 수 있는 변수 초기값
        for idx_l in range(a): # a보다 작은 인덱스 중에 0이 아닌 인덱스가 있는지 확인하고 있다면 a_l=1로 변경
            if r[idx_l] != 0:
                a_l = 1
                break # 한 개면 충분하므로 찾았으면 for문 탈출
        for idx_r in range(a, W): # a보다 큰 인덱스 중에 0이 아닌 인덱스가 있는지 확인하고 있다면 a_r=1로 변경
            if r[idx_r] != 0:
                a_r = 1
                break # 한 개면 충분하므로 찾았으면 for문 탈출
        if a_l and a_r: # 양 쪽 다 막혀 있다면 빗물 추가
            rain += 1
            r[a]=3 # 빗물이 찼다면 3으로 변경
            # 이 과정이 없어도 정답, 본인은 로직이 맞는지 확인하기 위한 용도로 사용
            # 이걸 넣으면 빗물이 찬 0이 3으로 변경되면서 위 연산이 조금 빨라짐
            # 결과 차이 Before 메모리 112692KB, 시간 128ms
            #          After 메모리 112624KB, 시간 120ms

print(rain)

'''
두 번째 줄에는 블록이 쌓인 높이를 받아서 이차원 배열로 표현
한 행씩 뽑아서 0의 인덱스를 리스트로 저장한 후
0의 인덱스 리스트에서 원소를 하나씩 뽑으면서 0이 아닌 다른 숫자로 양쪽이 막혀 있는지 확인
막혀 있다면 +1
아니면 다시 반복문 진행
'''
