# BOJ 14466. 소가 길을 건너간 이유 6 / D3
'''
문제
소가 길을 건너간 이유는 그냥 길이 많아서이다. 존의 농장에는 길이 너무 많아서, 길을 건너지 않고서는 별로 돌아다닐 수가 없다.
존의 농장에 대대적인 개편이 있었다. 이제 작은 정사각형 목초지가 N×N (2 ≤ N ≤ 100) 격자로 이루어져 있다.
인접한 목초지 사이는 일반적으로 자유롭게 건너갈 수 있지만, 그 중 일부는 길을 건너야 한다.
농장의 바깥에는 높은 울타리가 있어서 소가 농장 밖으로 나갈 일은 없다.
K마리의 (1 ≤ K ≤ 100,K ≤ N2) 소가 존의 농장에 있고, 각 소는 서로 다른 목초지에 있다.
어떤 두 소는 길을 건너지 않으면 만나지 못 할 수 있다. 이런 소가 몇 쌍인지 세어보자.

입력
첫 줄에 N, K, R이 주어진다. 다음 R줄에는 한 줄에 하나씩 길이 주어진다.
길은 상하좌우로 인접한 두 목초지를 잇고, r c r′ c′의 형태 (행, 열, 행, 열)로 주어진다. 각 수는 1 이상 N 이하이다.
그 다음 K줄에는 한 줄의 하나씩 소의 위치가 행과 열로 주어진다.

출력
길을 건너지 않으면 만날 수 없는 소가 몇 쌍인지 출력한다.
'''
import sys
input = sys.stdin.readline

N, K, R = map(int, input().split())
field = [[1]*(2*N-1) for _ in range(2*N-1)] # 필드를 N X N로 표현하는 것보다 필드 사이 사이에 거짓 값을 넣어서 길을 표현하기 쉽게 만듦

# 길을 건너지 않고 만날 수 없는 경우는 결국 길은 통행하지 못하는 곳으로 설정하고 나머지 만나는 케이스를 구해서 여사건으로 풀이
for _ in range(R):
    x, y, z, w = map(int, input().split())
    r1, c1, r2, c2 = 2*(x-1), 2*(y-1), 2*(z-1), 2*(w-1) # 거짓 값이 추가되어서 본 좌표들은 현재 필드에서 짝수 좌표에서만 존재
    field[(r1+r2)//2][(c1+c2)//2] = 0 # 길은 두 좌표를 연결하는 곳이므로 둘의 평균값으로 길 좌표를 설정함

cow = []
for _ in range(K):
    a, b = map(int, input().split())
    cow_i, cow_j = 2*(a-1), 2*(b-1)
    cow.append((cow_i, cow_j)) # 소 좌표를 따로 보관
    field[cow_i][cow_j] = 3 # 필드에서 소는 3으로 표시

no_meet = 0 # 모든 소를 가지고 DFS를 돌리고 구한 만나지 못하는 경우의 수
for i in range(K): # 소 한마리 당 만날 수 있는 소 카운트
    cnt = 0 # 만날 수 있는 소 카운트
    # DFS 사용
    stack = []
    stack.append(cow[i])
    visited = [[0]*(2*N-1) for _ in range(2*N-1)]
    visited[cow[i][0]][cow[i][1]] = 1
    while stack:
        i, j = stack.pop()
        for di, dj in [[1, 0], [-1, 0], [0, 1], [0, -1]]:
            ni, nj = i + 2*di, j + 2*dj # 소가 움직일 수 있는 좌표는 짝수 좌표들이므로 무조건 한번에 2칸을 뛰어넘어야 한다.
            # 하지만 길을 건너지 않는 것을 확인해야 하므로 field[ni-di][nj-dj] != 0 이 방식으로 확인 -> 가는 경로에 0이 있으면 안됨.
            if 0 <= ni < (2*N-1) and 0 <= nj < (2*N-1) and visited[ni][nj] == 0 and field[ni-di][nj-dj] != 0:
                stack.append((ni, nj))
                visited[ni][nj] = 1
                if field[ni][nj] == 3:
                    cnt += 1 # 다른 소를 만나면 카운트

    no_meet += K-cnt-1 # 특정 소가 움직일 때 만나지 못하는 다른 소 = 전체 소의 수 - 1(본인) - 만난 소의 수(cnt)

print(no_meet//2) # 중복해서 2번씩 세었기 때문에 쌍을 구하려면 2로 나누어줘야함.

'''
필드를 N X N로 표현하는 것보다 필드 사이 사이에 거짓 값을 넣어서 길을 표현하기 쉽게 만듦
예를 들어 3 X 3인 경우, 5 X 5가 되는 것임
예제 입력으로 풀이를 표현하자면
[[1, 1, 1],
 [1, 3, 3],
 [1, 1, 3]]
이런식으로 소들의 위치만 표현 가능하지 길은 따로 고려해야해서 복잡하기때문에
[[1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [1, 1, 3, 0, 3],
 [1, 1, 1, 1, 0],
 [1, 1, 1, 0, 3]]
이런 식으로 길은 0으로, 소는 3으로 표현할 수 있음
이렇게 한 후 DFS를 사용하고 총 구해진 경우의 수를 2로 나누어주면 쌍 수가 나오게 됨.
주의할 점은 소는 위 거짓값을 쓰면서 한칸씩 움직이는 것이 아니라 두칸씩 움직이게 됨.
가도 되는지 판단은 field[ni-di][nj-dj] != 0 이 조건을 활용.(두칸 뛰어넘는데 뛰어넘는 길에 0이 있으면 못감)
'''